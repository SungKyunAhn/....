package com.aimir.fep.bypass.actions;

import java.lang.reflect.Method;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;
import org.apache.mina.core.session.IoSession;
import org.springframework.orm.jpa.JpaTransactionManager;
import org.springframework.transaction.TransactionStatus;

import com.aimir.constants.CommonConstants.MeterEventKind;
import com.aimir.constants.CommonConstants.TR_STATE;
import com.aimir.dao.device.AsyncCommandLogDao;
import com.aimir.dao.device.AsyncCommandParamDao;
import com.aimir.dao.device.AsyncCommandResultDao;
import com.aimir.dao.device.MeterDao;
import com.aimir.dao.device.MeterEventLogDao;
import com.aimir.fep.bypass.BypassDevice;
import com.aimir.fep.bypass.decofactory.protocolfactory.BypassFrameFactory;
import com.aimir.fep.bypass.decofactory.protocolfactory.BypassFrameFactory.Procedure;
import com.aimir.fep.bypass.dlms.enums.ObjectType;
import com.aimir.fep.bypass.dlms.enums.Unit;
import com.aimir.fep.bypass.decofactory.protocolfactory.BypassFrameResult;
import com.aimir.fep.bypass.decofactory.protocolfactory.BypassSORIAFactory;
import com.aimir.fep.protocol.fmp.datatype.SMIValue;
import com.aimir.fep.protocol.fmp.frame.ControlDataConstants;
import com.aimir.fep.protocol.fmp.frame.ControlDataFrame;
import com.aimir.fep.util.DLMSCmdUtil;
import com.aimir.fep.util.DataUtil;
import com.aimir.fep.util.Hex;
import com.aimir.model.device.AsyncCommandLog;
import com.aimir.model.device.AsyncCommandParam;
import com.aimir.model.device.AsyncCommandResult;
import com.aimir.model.device.Meter;
import com.aimir.model.device.MeterEventLog;
import com.aimir.model.system.DeviceModel;
import com.aimir.util.Condition;
import com.aimir.util.Condition.Restriction;
import com.aimir.util.DateTimeUtil;


public class CommandAction_SP extends CommandAction {
	private static Log log = LogFactory.getLog(CommandAction_SP.class);

	@Override
	public void execute(String cmd, SMIValue[] smiValues, IoSession session) throws Exception {
		try {
			/*
			 * Norway Command List
			 * 1. cmdMeterParamGet
			 * 2. cmdMeterParamSet
			 * 3. cmdMeterOTAStart
			 * 4. 
			 */

			BypassDevice bd = (BypassDevice) session.getAttribute(session.getRemoteAddress());
			JpaTransactionManager txmanager = (JpaTransactionManager)DataUtil.getBean("transactionManager");
			TransactionStatus txstatus = null;

			AsyncCommandLogDao acld = null;
			Set<Condition> condition = null;

			String resultParams = "";

			if (0 < smiValues.length) {
				for (SMIValue value : smiValues) {
					resultParams += value.getVariable().toString() + ", ";
				}

				resultParams = resultParams.substring(0, resultParams.length() - 2);
				log.debug("### [" + cmd + "] Command Response params = " + resultParams);
			} else {
				log.debug("### [" + cmd + "] Command Response params is empty.");
			}

			/***********************************
			 * Response 처리
			 * 
			 * 아래와 같은 의미로 사용한다. 
			 * TR_STATE.Success (0) : Command 수행 성공및 정상종료 상태 
			 * TR_STATE.Waiting (1) : 서버측에서 SMS전송후 모뎀의 접속을 기다리는 상태
			 * TR_STATE.Running (2) : Command 수행중인 상태 
			 * TR_STATE.Terminate (4) : Command 가 성공하지 못한 상태에서 종료된 상태 (ex. crc error)
			 * TR_STATE.Delete (8) : 다른 Tranasction의 동일 Command가 실행되어(단지 실행) 삭제처리된 상태 
			 * TR_STATE.Unknown (255) : 아몰랑.
			 * 
			 ***********************************/
			//SP 모뎀/미터 식별 응답이 오면 커맨드를 실행한다.
			if (cmd.equals("cmdIdentifyDevice")) { // 모뎀 식별용 Command.
				bd.setModemId(smiValues[0].getVariable().toString());
				bd.setMeterId(smiValues[1].getVariable().toString());

				// 비동기 내역을 조회한다.
				List<AsyncCommandLog> acllist = null;
				acld = DataUtil.getBean(AsyncCommandLogDao.class);

				try {
					txstatus = txmanager.getTransaction(null);
					// 모뎀 번호로 조회
					condition = new HashSet<Condition>();
					condition.add(new Condition("deviceId", new Object[] { bd.getModemId() }, null, Restriction.EQ));
					condition.add(new Condition("state", new Object[] { TR_STATE.Waiting.getCode(), TR_STATE.Running.getCode() }, null, Restriction.IN));
					condition.add(new Condition("id.trId", null, null, Restriction.ORDERBY));
					acllist = acld.findByConditions(condition);
					
					log.debug("ModemID = " + bd.getModemId() + ", TransactionId = " + bd.getTransactionId() + " ASYNC_SIZE[" + acllist.size() + "]");

					txmanager.commit(txstatus);
				} catch (Exception e) {
					log.error("txmanagerError - " + e, e);
					if (txstatus != null)
						txmanager.rollback(txstatus);
				}

				if (acllist.size() > 0) {
					/*
					 * 기존에 수행하다 문제가 접속이 끊겨서 멈춘것들을 모두 Delete하고
					 * 마지막(가장최근) 트렌젝션으로 수행한다.
					 */
					AsyncCommandLog acl = null;
					List<AsyncCommandParam> acplist = null;
					try {
						txstatus = txmanager.getTransaction(null);

						for (int i = 0; i < acllist.size(); i++) {
							acl = acllist.get(i);
							if (i == acllist.size() - 1)
								acl.setState(TR_STATE.Running.getCode());
							else
								acl.setState(TR_STATE.Delete.getCode());
							acld.update(acl);
						}

						bd.setTrState(TR_STATE.Running);

						// 마지막 커맨드를 실행한다.
						acl = acllist.get(acllist.size() - 1);
						bd.setTransactionId(acl.getTrId());

						condition = new HashSet<Condition>();
						condition.add(new Condition("id.trId", new Object[] { acl.getTrId() }, null, Restriction.EQ));
						condition.add(new Condition("id.mcuId", new Object[] { acl.getMcuId() }, null, Restriction.EQ));
						AsyncCommandParamDao acpd = DataUtil.getBean(AsyncCommandParamDao.class);
						acplist = acpd.findByConditions(condition);

						txmanager.commit(txstatus);
					} catch (Exception e) {
						if (txstatus != null)
							txmanager.rollback(txstatus);
					}

					HashMap<String, Object> map = new HashMap<String, Object>();
					for (AsyncCommandParam param : acplist) {
						map.put(param.getParamType(), param.getParamValue());
					}
					bd.setArgMap(map);

					/**********************
					 * REQUEST 처리
					 **********************/

					String excuteCommandName = acl.getCommand();

					bd.setCommand(acl.getCommand());
					
					log.debug("EXCUTE CommandName => " + excuteCommandName);
					Method method = this.getClass().getMethod(excuteCommandName, IoSession.class);
					method.invoke(this, session);

					/**
					 * 아래 Command들은 리턴값이 없어서 상태를 체크할 수가 없음. 임의로 Command실행시
					 * 성공한것으로 처리함. 추후 리턴값을 받아서 처리 할경우 상태변경을 아래 로직에서 하지 말고 각
					 * Command Response 처리하는 부분에서 진행할것.
					 */
					if (acl.getCommand().equals("cmdMeterParamGet") 
							|| acl.getCommand().equals("cmdMeterParamSet")) {

						try {
							txstatus = txmanager.getTransaction(null);

							condition = new HashSet<Condition>();
							condition.add(new Condition("deviceId", new Object[] { bd.getModemId() }, null, Restriction.EQ));
							condition.add(new Condition("id.trId", new Object[] { bd.getTransactionId() }, null, Restriction.EQ));
							condition.add(new Condition("state", new Object[] { TR_STATE.Running.getCode() }, null, Restriction.EQ));
							// order by 날짜로
							List<AsyncCommandLog> acLogList = acld.findByConditions(condition);

							log.debug("TEMP ASYNC_SIZE[" + acLogList.size() + "]");

							if (acLogList.size() > 0) {
								for (int i = 0; i < acLogList.size(); i++) {
									AsyncCommandLog sacl = acLogList.get(i);
									sacl.setState(TR_STATE.Success.getCode());
									acld.update(sacl);
								}
								bd.setTrState(TR_STATE.Success);
							}

							txmanager.commit(txstatus);
						} catch (Exception e) {
							if (txstatus != null)
								txmanager.rollback(txstatus);
						}

					}

				} else {
					// 실행할 명령이 없으면 EOT 호출하고 종료
					session.write(new ControlDataFrame(ControlDataConstants.CODE_EOT));
				}
			}

		} catch (Exception e) {
			log.error(e, e);
		}
	}

	@Override
	public void executeBypass(byte[] rawFrame, IoSession session) throws Exception {
		log.debug("#### Receive Bypass Frame ==> " + Hex.decode(rawFrame));

		BypassDevice bd = (BypassDevice) session.getAttribute(session.getRemoteAddress());
		BypassFrameResult bypassFrameResult = (BypassFrameResult) bd.getFrameFactory().receiveBypass(session, rawFrame);

		log.debug("### [" + bd.getCommand() + "] Execute Bypass ==> " + bypassFrameResult.toString());
		JpaTransactionManager txmanager = (JpaTransactionManager)DataUtil.getBean("transactionManager");
		TransactionStatus txstatus = null;

		if (bd.getCommand().equals("cmdSetDLMSMeterTime")) {
				log.info("Received cmdSetDLMSMeterTime");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);

					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.SET_METER_TIME) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				log.error(bd.getCommand() + " Excute Error - " + e);
				
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}else if (bd.getCommand().equals("cmdGetDLMSMeterTime")) {
			log.info("Received cmdGetDLMSMeterTime");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());
				@SuppressWarnings("unchecked")
				HashMap<String, String> resultValue = bypassFrameResult.getResultValue() == null ? null : (HashMap<String, String>) bypassFrameResult.getResultValue();

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					if (resultValue != null) {
						if(resultValue.get("date").length() > 0) {
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"Date(YYYY/MM/DD)",resultValue.get("date"));
							acpd.add(asyncCommandResult);
						}
						if(resultValue.get("time").length() > 0) {
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"time(HH:MM:SS)",resultValue.get("time"));
							acpd.add(asyncCommandResult);
						}
					}

					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_METER_TIME) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"Date(YYYY/MM/DD)",resultValue.get("date"));
							acpd.add(asyncCommandResult);
							
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"time(HH:MM:SS)",resultValue.get("time"));
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}

					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				log.error(bd.getCommand() + " Excute Error - " + e);
				
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}else if (bd.getCommand().equals("cmdGetRegisterValue")) {
			log.info("Received cmdGetRegisterValue");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					if (bypassFrameResult.getResultValue() != null) {
						asyncCommandResult = setAsynCmdResult(bd,++nextNum,"value",String.valueOf(bypassFrameResult.getResultValue()));
					}
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_REGISTER_VALUE) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"value",String.valueOf(bypassFrameResult.getResultValue()));
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}else if (bd.getCommand().equals("cmdSetRegisterValue")) {
			log.info("Received cmdSetRegisterValue");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.SET_REGISTER_VALUE) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				log.error(bd.getCommand() + " Excute Error - " + e);
				
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}else if (bd.getCommand().equals("cmdGetRegisterUnit")) {
			log.info("Received cmdGetRegisterUnit");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());
				HashMap<String,Object> resultMap = bypassFrameResult.getResultValue() == null ? null : (HashMap<String, Object>) bypassFrameResult.getResultValue();
				
				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					if (resultMap != null) {
						if(resultMap.get("scaler") != null) {
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"Scaler",String.valueOf(bypassFrameResult.getResultValue()));
						}
						if(resultMap.get("unit") != null) {
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"Unit",Unit.forValue((int)resultMap.get("unit")).toString());
						}
						
					}
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_REGISTER_UNIT) {
							
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"Scaler/Unit",String.valueOf(resultMap.get("scaler"))+"/"+Unit.forValue((int)resultMap.get("unit")).toString());
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}else if (bd.getCommand().equals("cmdGetProfileBuffer")) {
			log.info("Received cmdGetProfileBuffer");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				MeterEventLogDao meterEventLogDao = DataUtil.getBean(MeterEventLogDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());
				@SuppressWarnings("unchecked")
				List<Object> resultList = (List<Object>) bypassFrameResult.getResultValue();
				String obisCode = (String) bd.getArgMap().get("obisCode");
				
				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);

					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_PROFILE_BUFFER) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							/*
							 * resultList 구성 형식
							 * resultList.get(0) : channel 정보 _{classId : 71(Limiter), attributeNo : 3(capture_object)}
							 * resultList.get(x) : channel 에 따른 data 정보 _{classId : 71(Limiter), attributeNo : 2(buffer)}
							 * 					   resultList.get(0)의 channel 순서대로 데이터가 정렬되어 올라옴.
							 * 
							 * ex) resultList.get(0) = {(classId=8,attribute=2,obisCode=0000010000FF),(classId=1,attribute=2,obisCode=0000600B00FF)}
							 *     resultList.get(1) = {20160602070000,1} //Clock,eventCode
							 *     resultList.get(2) = {20160602073000,1}
							 * 	   resultList.get(3) = {20160602073200,2}
							 * 
							 */
							if(resultList.size() > 0) {
								//resultList의 첫번째줄은 channel정보(capture_object)
								List<HashMap<String,Object>> channelList = (List<HashMap<String, Object>>) resultList.get(0);
								
								if(obisCode.matches("\\d+\\.\\d+\\.99\\.98\\.\\d+\\.255")) {
									log.info("#### Event Profile ####");
									//obis Code 가 x.x.x.98.x.ff 인 경우 Event Log (DLMS 표준)
									MeterDao meterDao = DataUtil.getBean(MeterDao.class);
									Meter meter = meterDao.get(bd.getMeterId());
									DeviceModel model = meter.getModel();
									SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMddHHmmss");
									for (int i = 1; i < resultList.size(); i++) {
										try{
											MeterEventLog meterLog = new MeterEventLog();
											List<Object> recData = (List<Object>) resultList.get(i);
											for (int j = 0; j < channelList.size(); j++) {
													
													HashMap<String,Object> tempChannel = channelList.get(j);
													String chlClassId = String.valueOf(tempChannel.get("classId"));
													String chlAttributeNo = String.valueOf(tempChannel.get("attribute"));
													String chlObisCode = String.valueOf(tempChannel.get("obisCode"));
													
													if(ObjectType.CLOCK.getValue() == Integer.parseInt(chlClassId) && 2 == Integer.parseInt(chlAttributeNo)) {
														String yyyymmddhhmmss = String.valueOf(recData.get(j));
														meterLog.setOpenTime(yyyymmddhhmmss);
														meterLog.setYyyymmdd(yyyymmddhhmmss.substring(0,8));
													} else if(ObjectType.DATA.getValue() == Integer.parseInt(chlClassId) && 2 == Integer.parseInt(chlAttributeNo)) {
														//eventCode 형식. 0.x.96.11.x.255 (DLMS 표준)
														if(chlObisCode.startsWith("0000600B") && chlObisCode.endsWith("FF")) {
															String eventCode =  String.valueOf(recData.get(j));
															switch (eventCode) {
															case "1":
																meterLog.setMessage("Power off");
																break;
															case "2":
																meterLog.setMessage("Power on");
																break;
															case "10":
																meterLog.setMessage("L2 voltage interruption");
																break;
															case "11":
																meterLog.setMessage("L3 voltage interruption");
																break;
															case "21":
																meterLog.setMessage("Self-diagnostic error");
																break;
															case "22":
																meterLog.setMessage("Change of clock");
																break;
															default:
																break;
															}
														}
													}
											}
											Calendar cal = Calendar.getInstance();
											String currTime = sdf.format(cal.getTime());
											String kind = MeterEventKind.STE.name();
											
											meterLog.setActivatorId(bd.getMeterId());
											meterLog.setMeterEventId(kind+"."+model.getDeviceVendor().getName() +"."+ model.getName()+"."+obisCode);
											meterLog.setActivatorType("EnergyMeter");
											meterLog.setSupplier(meter.getSupplier());
											meterLog.setWriteTime(currTime);
											meterEventLogDao.add(meterLog);
											meterEventLogDao.flushAndClear();
										} catch(Exception e) {
											log.error("Meter Event Save Error-" + e);
										}
										
									}
								} else if(obisCode.matches("\\d+\\.\\d+\\.\\99\\.(1|2)\\.\\d+\\.255")) {	
									log.info("#### Load Profile ####");
									
								}
							}
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e,e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		} else if (bd.getCommand().equals("cmdGetProfileObject")) {
			log.info("Received cmdGetProfileObject");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());
				@SuppressWarnings("unchecked")
				List<HashMap<String,Object>> returnList = bypassFrameResult.getResultValue() == null ? null : (List<HashMap<String, Object>>) bypassFrameResult.getResultValue();

				String obisCode = (String) bd.getArgMap().get("obisCode");
				
				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);

					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_PROFILE_OBJECT) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							for (int i = 0; i < returnList.size(); i++) {
								HashMap<String,Object> tempMap = returnList.get(i);
								asyncCommandResult = setAsynCmdResult(bd,++nextNum,"Channel "+ i+1,"ClassId["+ tempMap.get("classId")+"], ObisCode["+tempMap.get("obisCode")+"], AttributeNo["+tempMap.get("attribute")+"]");
								acpd.add(asyncCommandResult);
							}
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e,e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		} else if (bd.getCommand().equals("cmdGetProfilePeriod")) {
			log.info("Received cmdGetProfilePeriod");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_PROFILE_PERIOD) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"period(sec)",String.valueOf(bypassFrameResult.getResultValue()));
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		} else if (bd.getCommand().equals("cmdSetProfilePeriod")) {
			log.info("Received cmdSetRegisterValue");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.SET_PROFILE_PERIOD) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				log.error(bd.getCommand() + " Excute Error - " + e);
				
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		} else if (bd.getCommand().equals("cmdGetThresholdNormal")) {
			log.info("Received cmdGetThresholdNormal");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_THRESHOLD_NORMAL) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"Threshold normal",String.valueOf(bypassFrameResult.getResultValue()));
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		} else if (bd.getCommand().equals("cmdSetThresholdNormal")) {
			log.info("Received cmdSetThresholdNormal");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.SET_THRESHOLD_NORMAL) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				log.error(bd.getCommand() + " Excute Error - " + e);
				
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		} else if (bd.getCommand().equals("cmdGetMinOverThresholdDuration")) {
			log.info("Received cmdGetMinOverThresholdDuration");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);
					
					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_MINOVER_THRESHOLD_DURATION) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",((String) bypassFrameResult.getResultValue()));
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"Min over threshold duration",String.valueOf(bypassFrameResult.getResultValue()));
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		} else if (bd.getCommand().equals("cmdSetMinOverThresholdDuration")) {
			log.info("Received cmdSetMinOverThresholdDuration");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);
					
					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);

					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.SET_MINOVER_THRESHOLD_DURATION) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				log.error(bd.getCommand() + " Excute Error - " + e);
				
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}else if (bd.getCommand().equals("cmdGetRelayState")) {
			log.info("Received cmdGetRelayState");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					if (bypassFrameResult.getResultValue() != null) {
						asyncCommandResult = setAsynCmdResult(bd,++nextNum,"value",String.valueOf(bypassFrameResult.getResultValue()));
					}
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_DISCONNECT_CONTROL) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"value",String.valueOf(bypassFrameResult.getResultValue()));
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}else if (bd.getCommand().equals("cmdSetRelayState")) {
			log.info("Received cmdSetRelayState");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.SET_DISCONNECT_CONTROL) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				log.error(bd.getCommand() + " Excute Error - " + e);
				
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		} else if (bd.getCommand().equals("cmdGetMeterFWVersion")) {
			
		}else if (bd.getCommand().equals("cmdGetValue")) {
			log.info("Received cmdGetValue");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					if (bypassFrameResult.getResultValue() != null) {
						asyncCommandResult = setAsynCmdResult(bd,++nextNum,"value",String.valueOf(bypassFrameResult.getResultValue()));
					}
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.GET_DISCONNECT_CONTROL) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
							
							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"value",String.valueOf(bypassFrameResult.getResultValue()));
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}else if (bd.getCommand().equals("cmdSetValue")) {
			log.info("Received cmdSetValue");
			try {
				txstatus = txmanager.getTransaction(null);

				AsyncCommandResultDao acpd = DataUtil.getBean(AsyncCommandResultDao.class);
				int nextNum = acpd.getMaxNum(bd.getModemId(), bd.getTransactionId());

				// 실패시는 모두 저장
				if (!bypassFrameResult.isResultState()) {
					String lastProcedure = bypassFrameResult.getLastProcedure() == null ? bypassFrameResult.getStep().name() : bypassFrameResult.getLastProcedure().name();
					AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",lastProcedure);
					acpd.add(asyncCommandResult);

					asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Fail");
					acpd.add(asyncCommandResult);
					
					log.debug("Fail Result => " + asyncCommandResult.toJSONString());

					bypassTRStateChange(session);
				}
				// 성공시에는 DISC 까지 실행했을경우만 저장
				else {
					try {
						if (bypassFrameResult.isFinished() == true && bypassFrameResult.getLastProcedure() == Procedure.SET_DISCONNECT_CONTROL) {
							// Return값 저장
							AsyncCommandResult asyncCommandResult = setAsynCmdResult(bd,nextNum,"RESULT_STATUS",bypassFrameResult.getLastProcedure().name());
							acpd.add(asyncCommandResult);

							asyncCommandResult = setAsynCmdResult(bd,++nextNum,"RESULT_VALUE","Success");
							acpd.add(asyncCommandResult);
						}

					} catch (Exception e) {
						log.error("Procedure save error -" + e);
					}
					bypassTRStateChange(session);
				}

				txmanager.commit(txstatus);
			} catch (Exception e) {
				log.error(bd.getCommand() + " Excute Error - " + e);
				
				if (txstatus != null)
					txmanager.rollback(txstatus);
			}
		}
		log.debug("### [" + bd.getCommand() + "] Execute Bypass ok.");

		if (!bypassFrameResult.isResultState()) {
			bd.getFrameFactory().stop(session);
		}
	}

	private void bypassTRStateChange(IoSession session) {
		// 비동기 내역 수정
		try {
			AsyncCommandLogDao acld = null;
			Set<Condition> condition = null;
			BypassDevice bd = (BypassDevice) session.getAttribute(session.getRemoteAddress());

			acld = DataUtil.getBean(AsyncCommandLogDao.class);
			condition = new HashSet<Condition>();
			condition.add(new Condition("deviceId", new Object[] { bd.getModemId() }, null, Restriction.EQ));
			condition.add(new Condition("id.trId", new Object[] { bd.getTransactionId() }, null, Restriction.EQ));
			condition.add(new Condition("state", new Object[] { TR_STATE.Running.getCode() }, null, Restriction.EQ));
			// orderby 날짜로
			List<AsyncCommandLog> acLogList = acld.findByConditions(condition);
			log.debug("ASYNC_SIZE[" + acLogList.size() + "]");

			if (acLogList.size() > 0) {
				for (int i = 0; i < acLogList.size(); i++) {
					AsyncCommandLog acl = acLogList.get(i);
					acl.setState(TR_STATE.Success.getCode());
					acld.update(acl);
				}

				bd.setTrState(TR_STATE.Success);
			}
		} catch (Exception e) {
			log.error("TR State Change Error - ", e);
			
		}
	}

	public void cmdSetBypassStart(IoSession session) throws Exception {
		log.debug("## [cmdSetBypassStart] Action ~!!!");

		BypassDevice bd = (BypassDevice) session.getAttribute(session.getRemoteAddress());
		int timeout = 10;

		if (bd.getArgMap() != null && !bd.getArgMap().get("timeout").equals("")) {
			timeout = Integer.parseInt((String) bd.getArgMap().get("timeout"));
		}

		String ns = (String) session.getAttribute("nameSpace");
		List<SMIValue> params = new ArrayList<SMIValue>();
		params.add(DataUtil.getSMIValueByObject(ns, "cmdSetBypassStartTimeout", Integer.toString(timeout)));
		sendCommand(session, "cmdSetBypassStart", params);
	} 	
	
	/**
	 * cmdMeterParamGet
	 * 
	 * @param session
	 * @throws Exception
	 */
	public void cmdMeterParamGet(IoSession session) throws Exception {
		long startTime = System.currentTimeMillis();
		log.debug("## [cmdMeterParamGet] Start : " + DateTimeUtil.getDateString(startTime));

		BypassDevice bd = (BypassDevice) session.getAttribute(session.getRemoteAddress());
		String param = (String) bd.getArgMap().get("paramGet");
		
		String[] data = null;
		//obisCode|classId|attributeNo|accessRight|dataType|value
		//value는 ,로 구분한다.
		data = param.split("[|]");
		
		HashMap<String, Object> argMap = new HashMap<String, Object>();
		argMap.put("timeout", "60");
		argMap.put("obisCode", data[0]);
		bd.setArgMap(argMap);
		
		String cmd = DLMSCmdUtil.getCmdName(Integer.parseInt(data[1]),data[2],"Get");
		bd.setCommand(cmd);
		/*
		 * 1. Bypass Connection
		 */
		cmdSetBypassStart(session);
		
		/*
		 * 2. HDLC Connction.
		 */
		HashMap<String, Object> params = new HashMap<String, Object>();
		params.put("obisCode", data[0]);
		params.put("classId", data[1]);
		params.put("attributeNo", data[2]);
		
		if(data.length >= 6 && data[5] != null && !data[5].isEmpty()) {
			params.put("value", data[5]);
		}
		
		BypassFrameFactory gdFactory = new BypassSORIAFactory(bd.getMeterId(), cmd);
		bd.setFrameFactory(gdFactory);

		gdFactory.setParam(params);
		gdFactory.start(session, null);
	}
	
	/**
	 * cmdMeterParamSet
	 * 
	 * @param session
	 * @throws Exception
	 */
	public void cmdMeterParamSet(IoSession session) throws Exception {
		long startTime = System.currentTimeMillis();
		log.debug("## [cmdMeterParamSet] Start : " + DateTimeUtil.getDateString(startTime));
		
		BypassDevice bd = (BypassDevice) session.getAttribute(session.getRemoteAddress());
		String param = (String) bd.getArgMap().get("paramSet");
		
		String[] data = null;
		//obisCode|classId|attributeNo|accessRip/ght|dataType|value
		//value는 ,로 구분한다.
		data = param.split("[|]");
		
		HashMap<String, Object> argMap = new HashMap<String, Object>();
		argMap.put("timeout", "60");
		bd.setArgMap(argMap);
		
		String cmd = DLMSCmdUtil.getCmdName(Integer.parseInt(data[1]),data[2],"Set");
		bd.setCommand(cmd);
		/*
		 * 1. Bypass Connection
		 */
		cmdSetBypassStart(session);
		
		/*
		 * 2. HDLC Connction.
		 */
		HashMap<String, Object> params = new HashMap<String, Object>();
		params.put("obisCode", data[0]);
		params.put("classId", data[1]);
		params.put("attributeNo", data[2]);
		params.put("value", data[5]);

		BypassFrameFactory gdFactory = new BypassSORIAFactory(bd.getMeterId(),cmd);
		bd.setFrameFactory(gdFactory);

		gdFactory.setParam(params);
		gdFactory.start(session, null);

	}
	
	private AsyncCommandResult setAsynCmdResult(BypassDevice bd, Integer numb, String type, String value) {
		AsyncCommandResult asyncCommandResult = new AsyncCommandResult();
		asyncCommandResult.setMcuId(bd.getModemId());
		asyncCommandResult.setTrId(bd.getTransactionId());
		asyncCommandResult.setNum(numb);
		asyncCommandResult.setResultType(type);
		asyncCommandResult.setResultValue(value);
		return asyncCommandResult;
	}


}
